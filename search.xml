<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>三角剖分</title>
    <url>/2020/01/17/%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<h3 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h3><p>在几何中， 三角剖分是指将平面对象细分为三角形， 并且通过扩展高维几何对象细分为单纯形。 对于一个给定的点集， 有很多种三角剖分， 如：<br><img src="/2020/01/17/%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/1.svg" alt="图片1"></p>
<h3 id="Delaunay-三角剖分"><a href="#Delaunay-三角剖分" class="headerlink" title="Delaunay 三角剖分"></a>Delaunay 三角剖分</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在数学和计算几何中， 对于给定平面中的离散点集 $P$, 其 $Delaunay$ 三角剖分 $DT(P)$ 满足：</p>
<ol>
<li>空圆性： $DT(P)$ 是 <strong>唯一</strong> 的（任意四点不共园）， 在 DT(P) 中, 任意三角形的外接圆范围内不会有其它点存在。</li>
<li>最大化最小角： 在点集 $P$ 可能形成的三角剖分中， $DT(P)$ 所形成的三角形的最小角最大。 从这个意义上来讲， $DT(P)$ 是最接近规则化的三角剖分。 具体说是在两个相邻的三角形构成的凸四边形的对角线， 在相互交换后， 两个内角的最小角不再增大。</li>
</ol>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>Pick</title>
    <url>/2020/01/17/Pick/</url>
    <content><![CDATA[<h3 id="定理描述"><a href="#定理描述" class="headerlink" title="定理描述"></a>定理描述</h3><p>Pick定理 : 给定整数坐标系， 在该系上的简单多边形， 其面积 $A$ 与内部格点数目 $i$, 边上格点数目 $b$ 有： $A = i + \frac{b}{2} - 1$。</p>
<h3 id="定理推广"><a href="#定理推广" class="headerlink" title="定理推广"></a>定理推广</h3><ul>
<li>取格点的组成图形面积为一单位。在平行四边形格点，Pick定理依然成立。</li>
<li>对于非简单的多边形 $P$ ， Pick定理 $A = i + \frac{b}{2} - x(P)$, 其中 $x(P)$ 表示 $P$ 的 <strong>欧拉特征数</strong>。</li>
<li>Ehrhart多项式</li>
<li>Pick定理 和 <strong>欧拉公式</strong> ($V - E + F = 2$) 等价。</li>
</ul>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p> POJ1265</p>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>动态DP</title>
    <url>/2020/01/03/%E5%8A%A8%E6%80%81DP/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>动态规划 - 优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>树形DP</title>
    <url>/2020/01/03/%E6%A0%91%E5%BD%A2DP/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>区间DP</title>
    <url>/2020/01/03/%E5%8C%BA%E9%97%B4DP/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>单调队列优化</title>
    <url>/2020/01/03/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>动态规划 - 优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>斜率优化</title>
    <url>/2020/01/03/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>动态规划 - 优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>四边形不等式优化</title>
    <url>/2020/01/03/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p><img src="/2020/01/03/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96/markdown-img-paste-20200104232045288.png" alt="图片"></p>
]]></content>
      <categories>
        <category>动态规划 - 优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>WQS二分</title>
    <url>/2020/01/03/WQS%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>动态规划 - 优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀数组</title>
    <url>/2020/01/03/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="算法相关"><a href="#算法相关" class="headerlink" title="算法相关"></a>算法相关</h2><h4 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h4><p>给出一个字符串S[1…n]，则后缀 $i$ 表示 S[i…n]</p>
<h4 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h4><p>将后缀 1 - n 按照字典序由小到大进行排序，得到SA数组为后缀数组。<br>如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S : hello</span><br><span class="line">SA : [2,1,4,3,5]</span><br><span class="line">1 : ello(后缀2)</span><br><span class="line">2 : hello(后缀1)</span><br><span class="line">3 : lo(后缀4)</span><br><span class="line">4 : llo(后缀3)</span><br><span class="line">5 : o(后缀5)</span><br></pre></td></tr></table></figure></p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p><a href="https://cyx13935786602.github.io">排序相关</a></p>
<h2 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h2><p>这里介绍一种倍增求解的方法, 如图：</p>
<p><img src="/2020/01/03/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/1.png" alt="bit"></p>
<p>可以知道其时间复杂度为O($logn \times T$), 其中 $T$ 为排序的时间复杂度。由此得到使用快速排序的时间复杂度为 O($nlog^2n$)。但我们通常改用基数排序的方法使得其时间复杂度降为 O($nlogn$)， 以达到更高的效率。</p>
<p>因此我们可以得到如下算法步骤：</p>
<ol>
<li>得到当前字符串长度 $k$（由 $1$ 开始倍增）</li>
<li>获取 $n$ 个字符串 , 第 $i$ 个字符串(后缀 $i$ )组成为 [$x$, $y$] : [$rank_i$, $rank_{i+k}$])</li>
<li>对 $n$ 个字符串进行排序并维护新的<strong>rank</strong>数组</li>
<li>当<strong>rank</strong>数组中所有值均不相同时停止倍增(由于已经两两互异，继续倍增已不会对<strong>rank</strong>数组产生影响)</li>
<li>维护SA数组(基数排序过程中可以顺带维护)<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2></li>
</ol>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/2020/01/03/KMP/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机</title>
    <url>/2020/01/03/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Manachar</title>
    <url>/2020/01/03/Manachar/</url>
    <content><![CDATA[<h2 id="算法简述"><a href="#算法简述" class="headerlink" title="算法简述"></a>算法简述</h2><p>给定一个长度为 $n$ 的字符串 $s$, 找到所有的数对 (i, j), 使得字串s[i…j]是回文串。 当且仅当 $t = t_{rec}$ 时， 字符串 $t$ 为一个回文子串。</p>
<p>朴素算法用 O($n^2$) 时间预处理出所有回文串， 而Manachar算法可以在 O(n) 线性时间内预处理出所需答案。</p>
<h2 id="算法内容"><a href="#算法内容" class="headerlink" title="算法内容"></a>算法内容</h2><p>我们设数组 P[ ] 为以 $i$ 为中心的向右扩展回文串长度。</p>
<p>我们假设我们已经维护前 $i - 1$ 的 P[ ]。设 $maxlen$ 为前 $i - 1$ 个 字串(l, r)中的最大右边界 $r_{max}$, $cet$ 为该字串中心, 在我们维护 P[ i ] 时有以下情况：</p>
<ul>
<li>当 $i + P[2 <em> cet - i] &lt;= maxlen$ 时 :   P[i] = P[2 </em> cet - i];<blockquote>
<p>相关证明：<br>我们已知道 (l = cet - P[cet], r = cet + P[cet]) 是以 $cet$ 为中心的回文串， 算法实际情况如图：</p>
<script type="math/tex; mode=display">\ldots\ \overbrace{s_{l + 1}\ \ldots\ \underbrace{s_{j - P[j] + 1}\ \ldots\ s_{j}\ \ldots\ s_{j + P[j] - 1}}_\text{回文串}\ \ldots\ \underbrace{s_{i - P[j] + 1}\ \ldots\ s_{i}\ \ldots\ s_{i + P[j] - 1}}_\text{回文串}\ \ldots\ s_{r - 1}\ }^\text{回文串} \ldots</script></blockquote>
</li>
<li>当 $i + P[2 * cet - i] &gt; maxlen$ 时 ： P[i] = maxlen - i;<blockquote>
<p>相关证明：<br>如图：</p>
<script type="math/tex; mode=display">\ldots\ \overbrace{\underbrace{s_{l + 1}\ \ldots\ s_{j}\ \ldots\ s_{j + (r - i) - 1}}_\text{字符串}\ \ldots\ \underbrace{s_{i - (r - i) + 1}\ \ldots\ s_{i}\ \ \ldots\ s_{r - 1}}_\text{字符串}\ }^\text{回文串} \ldots</script></blockquote>
</li>
</ul>
<p>因此 P[ i ] = min { P[2 * cet - i] , maxlen - i }</p>
<p>但此时的 P[ i ] 还并不是正确的值，我们接下来可以用朴素算法维护出正确的 P[ i ];<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(s[i + P[i]] == s[i - P[i]]) P[i]++;</span><br></pre></td></tr></table></figure></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Kruskal重构树</title>
    <url>/2020/01/03/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>0-1树</title>
    <url>/2020/01/03/0-1%E6%A0%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>可持续化数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>主席树</title>
    <url>/2020/01/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构 - 可持续化</category>
      </categories>
      <tags>
        <tag>可持续化数据结构</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LCT</title>
    <url>/2020/01/03/LCT/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树套树</title>
    <url>/2020/01/03/%E6%A0%91%E5%A5%97%E6%A0%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构 - 嵌套</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>嵌套</tag>
      </tags>
  </entry>
  <entry>
    <title>Treap</title>
    <url>/2020/01/03/Treap/</url>
    <content><![CDATA[<p><img src="/2020/01/03/Treap/e.png" alt="图片"></p>
]]></content>
      <categories>
        <category>数据结构 - 平衡树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>Splay</title>
    <url>/2020/01/03/Splay/</url>
    <content><![CDATA[<p><img src="/2020/01/03/Splay/e.png" alt="图片"></p>
]]></content>
      <categories>
        <category>数据结构 - 平衡树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>左偏树</title>
    <url>/2020/01/03/%E5%B7%A6%E5%81%8F%E6%A0%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构 - 堆</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>数值积分</title>
    <url>/2020/01/03/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title>分段打表</title>
    <url>/2020/01/03/%E5%88%86%E6%AE%B5%E6%89%93%E8%A1%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数学 - 暴力</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>牛顿迭代法</title>
    <url>/2020/01/03/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>迭代法</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数</title>
    <url>/2020/01/03/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>线性规划</title>
    <url>/2020/01/03/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论学习</title>
    <url>/2020/01/03/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数学 - 博弈论</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数列</title>
    <url>/2020/01/03/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：$1、1、2、3、5、8、13、21、34、\ldots$在数学上，斐波那契数列以如下被以递推的方法定义：$F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)(n \ge 3，n \in N^*)$ 在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从1963年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。</p>
<p align="right">——摘自百度百科</p>

<h2 id="通项公式"><a href="#通项公式" class="headerlink" title="通项公式"></a>通项公式</h2><p>由特征方程求解， 由于在OI中通项公式不常用到（但是仍然有用）， 这里只给出解析解， 不给出证明， 证明可参考<a href="https://baike.baidu.com/item/%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/2678218?fr=aladdin" target="_blank" rel="noopener">特征方程</a>。</p>
<script type="math/tex; mode=display">
F_n = \frac{\left(\frac{1 + \sqrt{5}}{2}\right)^n - \left(\frac{1 - \sqrt{5}}{2}\right)^n}{\sqrt{5}}</script><p>进一步的， 由于第二项指数级的减小， 所以可以写成：</p>
<script type="math/tex; mode=display">
F_n = \left[\frac{\left(\frac{1+\sqrt5}{2}\right)^n}{\sqrt5}\right]</script><p>中括号表示取离它最近的整数。</p>
<blockquote>
<p>注意!</p>
<p>这两个式子在计算时需要极高的精确度</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2></blockquote>
<p>这里列出相关性质与其简易证明：</p>
<ol>
<li>Cassini’s identity : $F_{n-1}F_{n+1}-F_{n}^2 = (-1)^n$</li>
<li>附加性质 : $F_{n + k} = F_kF_{n + 1} + F_{k-1}F_n$</li>
<li>取 (2) 中 $k = n$, 得到 $F_{2n} = F_{n}(F_{n + 1} + F_{n - 1})$</li>
<li>对 (3) 进行数学归纳得, $\forall k \in \mathbb{N}, F_{n} | F_{nk}$</li>
<li>由于 (4) 可逆， 得到 $\forall F_a | F_b, a | b$</li>
<li>GCD性质: $\gcd(F_n, F_m) = F_{\gcd(n, m)}$</li>
<li>前缀和性质： $\Sigma_{i = 1}^{n}F_i = F_{n+2} - 1$</li>
<li>$\Sigma_{i=1}^{n}{i \times F_i} = nF_{n+2} - F_{n+3} + 2$</li>
</ol>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质(1)"></a>性质(1)</h4><p>待施工</p>
<h3 id="模意义下的周期性"><a href="#模意义下的周期性" class="headerlink" title="模意义下的周期性"></a>模意义下的周期性</h3><p>考虑模 $p$ 意义下的斐波那契数列， 由抽屉原理易证，该数列有周期性。考虑模 $p$ 意义下的斐波那契数列的前 $p^{2} + 1$个相邻数对:</p>
<script type="math/tex; mode=display">
(F_1,F_2),(F_2,F_3),\ldots,(F_{p^2+1}, F_{p^2+2})</script><p>由于 $p$ 的剩余系大小为 $p$, 则这 $p^2 + 1$ 个数对中必有二项完全相同，则由此两项推出的数完全相同，原命题得证。</p>
<h2 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h2><h3 id="递推法"><a href="#递推法" class="headerlink" title="递推法"></a>递推法</h3><p>由递推公式 $F_{i+2} = F_{i+1} + F_{i}$ 在O(n)内得到。</p>
<h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p>斐波那契矩阵表达式：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
F_{i+2}\\
F_{i+1}\\
\end{bmatrix}
=
\begin{bmatrix}
1&1\\
1&0\\
\end{bmatrix}
\cdot
\begin{bmatrix}
F_{i+1}\\
F_{i}\\
\end{bmatrix}</script><p>令$P = \begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}$, 得到 $\begin{bmatrix}F_{n+2}\\F_{n+1}\end{bmatrix}=P^n \cdot \begin{bmatrix}F_2\\F_1\end{bmatrix}$</p>
<h3 id="快速倍增法"><a href="#快速倍增法" class="headerlink" title="快速倍增法"></a>快速倍增法</h3><p>由其性质(2)得到：</p>
<script type="math/tex; mode=display">
F_{2n} = F_{n}(2F_{n+1} - F_{n})\\
F_{2n+1} = F_{n+1}^2 + F_{n}^2\\</script><p>可以通过二元组($F_{i+1}$, $F_i$), 进行倍增运算<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; fib(<span class="keyword">int</span> n) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">  <span class="keyword">auto</span> p = fib(n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> c = p.first * (<span class="number">2</span> * p.second - p.first);</span><br><span class="line">  <span class="keyword">int</span> d = p.first * p.first + p.second * p.second;</span><br><span class="line">  <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;d, c + d&#125;;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> &#123;c, d&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Min_25筛</title>
    <url>/2020/01/03/Min-25%E7%AD%9B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数学 - 数论</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>杜教筛</title>
    <url>/2020/01/03/%E6%9D%9C%E6%95%99%E7%AD%9B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数学 - 数论</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>莫比乌斯反演</title>
    <url>/2020/01/03/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数学 - 数论</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Lucas定理</title>
    <url>/2020/01/03/Lucas%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="定理描述"><a href="#定理描述" class="headerlink" title="定理描述"></a>定理描述</h2><p>Lucas 定理用于求解组合数取模问题，其中模数 $p$ 为质数。</p>
<blockquote>
<p>Lucas 定理 :</p>
<blockquote>
<p>$C_{n}^{m} \equiv \prod_{i = 1}^{k} C_{n_i}^{m_i} \pmod p$, 其中 $n_i, m_i$ 为 $n, m$ 在 $p$ 进制下第 $i$ 位的数字</p>
</blockquote>
</blockquote>
<h2 id="定理证明"><a href="#定理证明" class="headerlink" title="定理证明"></a>定理证明</h2><p>考虑 $C_{p}^{n} \bmod p$ 的取值， 因为 $\displaystyle C_{p}^{n} = \frac{p!}{n!(p-n)!}$ ，分子的质因数分解中 $p$ 次项恰好为 $1$, 因此只有当 $n = 0$ 或 $n = p$ 时, 分子 $n!(p - n)!$ 的质因数分解中含有 $p$ , 因此 $C_{p}^{n} \bmod p = [n = 0 \vee n = p]$ 。</p>
<p>由此, 我们可以得到更强的结论：</p>
<script type="math/tex; mode=display">
\begin{align}
(a + b) ^ {p} &= \Sigma_{n = 0}^{p} C_{p}^{n}a^{n}b^{p-n} \\
&\equiv \Sigma_{n = 0}^{p}[n = 0 \vee n = p]a^{n}b^{p-n} \pmod p\\
&\equiv a^{p} + b^{p} \pmod p\\
\end{align}</script><blockquote>
<p>Tips:<br>此结论不仅适用于整数域， 同样适用于多项式。</p>
<p>由此可推导出二项式 $f(x) = (ax^{n} + bx^m)^p \bmod p$ 的结果为：</p>
<script type="math/tex; mode=display">
\begin{align}
(ax^n + bx^m) ^ p &\equiv a^px^{pn} + b^{p}x^{pm} \\
&\equiv ax^{pn} + bx^{pm} \\
&\equiv f(x^p) \pmod p \\
\end{align}</script></blockquote>
<p>考虑二项式 $(1 + x)^n \bmod p$, 那么 $C_{n}^{m}$ 就是求二项式在 $x_{m}$ 次项的值。<br>使用上述引理， 可以知道：</p>
<script type="math/tex; mode=display">
\begin{align}
(1 + x) ^ {n} &\equiv (1 + x) ^ {p\lfloor n/p \rfloor}(1 + x)^{n \bmod p}\\
&\equiv (1 + x^{p})^{\lfloor n/p \rfloor}(1 + x)^{n \bmod p}\\
\end{align}</script><p>注意到前者只有在 $p$ 的倍数处才能产生贡献，而对于后者有 $n \bmod p \le p - 1$, 因此其卷积在任何位置只有最多一种方式产生贡献，得到：</p>
<script type="math/tex; mode=display">
\binom{m}{n} \equiv \binom{\lfloor m/q \rfloor}{\lfloor n/q \rfloor} \times \binom{m \bmod p}{n \bmod p} \pmod p</script><h2 id="代码实现-c"><a href="#代码实现-c" class="headerlink" title="代码实现(c++)"></a>代码实现(c++)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>BGSG</title>
    <url>/2020/01/03/BGSG/</url>
    <content><![CDATA[<h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>BSGS（baby-step gaint-step），即大步小步算法。常用于求解离散对数问题。</p>
<script type="math/tex; mode=display">
a^x \equiv b \pmod p</script><p>其中$a \perp p$。 方程的解 $x$ 满足 $0 \le x &lt; p$。</p>
<h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><ol>
<li>设集合S = {$k | k = a^i \bmod p$}</li>
<li>计算$a^i \bmod p , i \in [1, \sqrt p]$, 加入集合S</li>
<li>在集合S中查找b，若不存在所需元素，则$b = b \times a^{\sqrt p} \bmod p$；若存在该元素，则得到一个可行解。</li>
</ol>
<h2 id="算法证明"><a href="#算法证明" class="headerlink" title="算法证明"></a>算法证明</h2><p>因为$a \perp b$， 所以由<strong>费马小定理</strong>得到$a^{p - 1} = 1 \pmod p$； 因此只需要求解$x \in [1, p - 1]$ 中的解$x$即可（ $x &gt; p$ 后所得值重复）。由此得到朴素O（p）算法：枚举x的值。 对该算法进行优化，运用分块思想， 将总序列分为 T 块，则每块元素个数为 $\left( \frac{p}{T} \right)$, 得到总时间复杂度为O($\frac{p}{T} + T$), 易证当 $T = \sqrt p$ 时时间复杂度最低。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>计算 [1, $\sqrt p$] 为 O($\sqrt p$), 之后最多 $\sqrt p$ 次查询。</p>
<p>总时间复杂度为$O(\sqrt p)$</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数学 - 数论</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>中国剩余定理-CRT</title>
    <url>/2020/01/03/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86-CRT/</url>
    <content><![CDATA[<h3 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h3><p>中国剩余定理（Chinese Remainder Theorem, CRT）是用来求解如下形式的一元线性同余方程组<br>($\forall b_{k} \in N$) ：</p>
<script type="math/tex; mode=display">
\begin{cases}
x &\equiv& a_1 \pmod {b_{1}}\\
x &\equiv& a_2 \pmod {b_{2}}\\
  &\vdots&\\
x &\equiv& a_n \pmod {b_{n}}\\
\end{cases}</script><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p><strong>两个方程合并</strong></p>
<p>设两个方程分别为 ：<br>$x \equiv a_1 \pmod {m_1}$,<br>$x \equiv a_2 \pmod {m_2}$.</p>
<p>转化为不定方程：$x = m_1p + a_1, x = m_2q + a_2$ , $p, q \in N^*$,则有$m_1p - m_2q = a_2 - a_1$.</p>
<p>由裴蜀定理， 当 $a_2 - a_1$ 不能被 $\gcd(m_1, m_2)$ 整除时， 无解；</p>
<p>其他情况下， 可通过EXGCD解出来一组可行解 $(p, q)$ ；</p>
<p>则原来的两个方程组成的模方程组的解为$x \equiv b \pmod M$, 其中 $b = m_1p + a_1, M = \text{lcm}(m_1, m_2)$</p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ol>
<li>获取两个模方程</li>
<li>合并两个模方程</li>
<li>重复上述操作， 得到所有模方程的合并方程<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>数学 - 数论</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
</search>
