<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>动态DP</title>
    <url>/2020/01/03/%E5%8A%A8%E6%80%81DP/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>动态规划 - 优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>树形DP</title>
    <url>/2020/01/03/%E6%A0%91%E5%BD%A2DP/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>区间DP</title>
    <url>/2020/01/03/%E5%8C%BA%E9%97%B4DP/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>单调队列优化</title>
    <url>/2020/01/03/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>动态规划 - 优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>斜率优化</title>
    <url>/2020/01/03/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>动态规划 - 优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>四边形不等式优化</title>
    <url>/2020/01/03/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p><img src="assets/markdown-img-paste-20200104232045288.png" alt="图片"></p>
]]></content>
      <categories>
        <category>动态规划 - 优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>WQS二分</title>
    <url>/2020/01/03/WQS%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>动态规划 - 优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀数组</title>
    <url>/2020/01/03/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/2020/01/03/KMP/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机</title>
    <url>/2020/01/03/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Manachar</title>
    <url>/2020/01/03/Manachar/</url>
    <content><![CDATA[<h2 id="算法简述"><a href="#算法简述" class="headerlink" title="算法简述"></a>算法简述</h2><p>给定一个长度为 $n$ 的字符串 $s$, 找到所有的数对 (i, j), 使得字串s[i…j]是回文串。 当且仅当 $t = t_{rec}$ 时， 字符串 $t$ 为一个回文子串。</p>
<p>朴素算法用 O($n^2$) 时间预处理出所有回文串， 而Manachar算法可以在 O(n) 线性时间内预处理出所需答案。</p>
<h2 id="算法内容"><a href="#算法内容" class="headerlink" title="算法内容"></a>算法内容</h2><p>我们设数组 P[ ] 为以 $i$ 为中心的向右扩展回文串长度。</p>
<p>我们假设我们已经维护前 $i - 1$ 的 P[ ]。设 $maxlen$ 为前 $i - 1$ 个 字串(l, r)中的最大右边界 $r_{max}$, $cet$ 为该字串中心, 在我们维护 P[ i ] 时有以下情况：</p>
<ul>
<li>当 $i + P[2 <em> cet - i] &lt;= maxlen$ 时 :   P[i] = P[2 </em> cet - i];<blockquote>
<p>相关证明：<br>我们已知道 (l = cet - P[cet], r = cet + P[cet]) 是以 $cet$ 为中心的回文串， 算法实际情况如图：</p>
<script type="math/tex; mode=display">\ldots\ \overbrace{s_{l + 1}\ \ldots\ \underbrace{s_{j - P[j] + 1}\ \ldots\ s_{j}\ \ldots\ s_{j + P[j] - 1}}_\text{回文串}\ \ldots\ \underbrace{s_{i - P[j] + 1}\ \ldots\ s_{i}\ \ldots\ s_{i + P[j] - 1}}_\text{回文串}\ \ldots\ s_{r - 1}\ }^\text{回文串} \ldots</script></blockquote>
</li>
<li>当 $i + P[2 * cet - i] &gt; maxlen$ 时 ： P[i] = maxlen - i;<blockquote>
<p>相关证明：<br>如图：</p>
<script type="math/tex; mode=display">\ldots\ \overbrace{\underbrace{s_{l + 1}\ \ldots\ s_{j}\ \ldots\ s_{j + (r - i) - 1}}_\text{字符串}\ \ldots\ \underbrace{s_{i - (r - i) + 1}\ \ldots\ s_{i}\ \ \ldots\ s_{r - 1}}_\text{字符串}\ }^\text{回文串} \ldots</script></blockquote>
</li>
</ul>
<p>因此 P[ i ] = min { P[2 * cet - i] , maxlen - i }</p>
<p>但此时的 P[ i ] 还并不是正确的值，我们接下来可以用朴素算法维护出正确的 P[ i ];<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(s[i + P[i]] == s[i - P[i]]) P[i]++;</span><br></pre></td></tr></table></figure></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Kruskal重构树</title>
    <url>/2020/01/03/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>0-1树</title>
    <url>/2020/01/03/0-1%E6%A0%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>可持续化数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>主席树</title>
    <url>/2020/01/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构 - 可持续化</category>
      </categories>
      <tags>
        <tag>可持续化数据结构</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LCT</title>
    <url>/2020/01/03/LCT/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树套树</title>
    <url>/2020/01/03/%E6%A0%91%E5%A5%97%E6%A0%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构 - 嵌套</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>嵌套</tag>
      </tags>
  </entry>
  <entry>
    <title>Treap</title>
    <url>/2020/01/03/Treap/</url>
    <content><![CDATA[<p><img src="/2020/01/03/Treap/e.png" alt="图片"></p>
]]></content>
      <categories>
        <category>数据结构 - 平衡树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>Splay</title>
    <url>/2020/01/03/Splay/</url>
    <content><![CDATA[<p><img src="/2020/01/03/Splay/e.png" alt="图片"></p>
]]></content>
      <categories>
        <category>数据结构 - 平衡树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>左偏树</title>
    <url>/2020/01/03/%E5%B7%A6%E5%81%8F%E6%A0%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构 - 堆</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>数值积分</title>
    <url>/2020/01/03/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title>分段打表</title>
    <url>/2020/01/03/%E5%88%86%E6%AE%B5%E6%89%93%E8%A1%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数学 - 暴力</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>牛顿迭代法</title>
    <url>/2020/01/03/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>迭代法</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数</title>
    <url>/2020/01/03/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>线性规划</title>
    <url>/2020/01/03/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论学习</title>
    <url>/2020/01/03/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数学 - 博弈论</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数列</title>
    <url>/2020/01/03/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Min_25筛</title>
    <url>/2020/01/03/Min-25%E7%AD%9B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数学 - 数论</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>杜教筛</title>
    <url>/2020/01/03/%E6%9D%9C%E6%95%99%E7%AD%9B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数学 - 数论</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>莫比乌斯反演</title>
    <url>/2020/01/03/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数学 - 数论</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Lucas定理</title>
    <url>/2020/01/03/Lucas%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>BGSG</title>
    <url>/2020/01/03/BGSG/</url>
    <content><![CDATA[<h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>BSGS（baby-step gaint-step），即大步小步算法。常用于求解离散对数问题。</p>
<script type="math/tex; mode=display">
a^x \equiv b \pmod p</script><p>其中$a \perp b$。 方程的解 $x$ 满足 $0 \le x &lt; p$。</p>
<h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><ol>
<li>设集合S = {$k | k = a^i \bmod p$}</li>
<li>计算$a^i \bmod p , i \in [1, \sqrt p]$, 加入集合S</li>
<li>在集合S中查找b，若不存在所需元素，则$b = b \times a^{\sqrt p} \bmod p$；若存在该元素，则得到一个可行解。</li>
</ol>
<h2 id="算法证明"><a href="#算法证明" class="headerlink" title="算法证明"></a>算法证明</h2><p>因为$a \perp b$， 所以由<strong>费马小定理</strong>得到$a^{p - 1} = 1 \pmod p$； 因此只需要求解$x \in [1, p - 1]$ 中的解$x$即可（ $x &gt; p$ 后所得值重复）。由此得到朴素O（p）算法：枚举x的值。 对该算法进行优化，运用分块思想， 将总序列分为 T 块，则每块元素个数为 $\left( \frac{p}{T} \right)$, 得到总时间复杂度为O($\frac{p}{T} + T$), 易证当 $T = \sqrt p$ 时时间复杂度最低。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>计算 [1, $\sqrt p$] 为 O($\sqrt p$), 之后最多 $\sqrt p$ 次查询。</p>
<p>总时间复杂度为$O(\sqrt p)$</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数学 - 数论</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>中国剩余定理-CRT</title>
    <url>/2020/01/03/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86-CRT/</url>
    <content><![CDATA[<h3 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h3><p>中国剩余定理（Chinese Remainder Theorem, CRT）是用来求解如下形式的一元线性同余方程组<br>($\forall b_{k} \in N$) ：</p>
<script type="math/tex; mode=display">
\begin{cases}
x &\equiv& a_1 \pmod {b_{1}}\\
x &\equiv& a_2 \pmod {b_{2}}\\
  &\vdots&\\
x &\equiv& a_n \pmod {b_{n}}\\
\end{cases}</script><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p><strong>两个方程合并</strong></p>
<p>设两个方程分别为 ：<br>$x \equiv a_1 \pmod {m_1}$,<br>$x \equiv a_2 \pmod {m_2}$.</p>
<p>转化为不定方程：$x = m_1p + a_1, x = m_2q + a_2$ , $p, q \in N^*$,则有$m_1p - m_2q = a_2 - a_1$.</p>
<p>由裴蜀定理， 当 $a_2 - a_1$ 不能被 $\gcd(m_1, m_2)$ 整除时， 无解；</p>
<p>其他情况下， 可通过EXGCD解出来一组可行解 $(p, q)$ ；</p>
<p>则原来的两个方程组成的模方程组的解为$x \equiv b \pmod M$, 其中 $b = m_1p + a_1, M = \text{lcm}(m_1, m_2)$</p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ol>
<li>获取两个模方程</li>
<li>合并两个模方程</li>
<li>重复上述操作， 得到所有模方程的合并方程<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>数学 - 数论</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
</search>
