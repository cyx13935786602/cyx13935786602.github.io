{"meta":{"title":"CBlog","subtitle":"记录学习","description":"","author":"Soch_","url":"https://cyx13935786602.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-01-03T13:29:52.000Z","updated":"2020-01-04T16:42:07.340Z","comments":false,"path":"categories/index.html","permalink":"https://cyx13935786602.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-01-03T12:51:36.000Z","updated":"2020-01-04T16:41:19.788Z","comments":false,"path":"about/index.html","permalink":"https://cyx13935786602.github.io/about/index.html","excerpt":"","text":"本BLOG用于记录学习进程。 可用于学习和交流。"},{"title":"guestbook","date":"2020-01-04T14:16:20.000Z","updated":"2020-01-04T14:16:20.884Z","comments":true,"path":"guestbook/index.html","permalink":"https://cyx13935786602.github.io/guestbook/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-03T13:26:28.000Z","updated":"2020-01-04T16:42:22.844Z","comments":false,"path":"tags/index.html","permalink":"https://cyx13935786602.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"三角剖分","slug":"三角剖分","date":"2020-01-17T06:54:13.000Z","updated":"2020-01-23T00:47:26.236Z","comments":true,"path":"2020/01/17/三角剖分/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/17/%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/","excerpt":"","text":"算法简介在几何中， 三角剖分是指将平面对象细分为三角形， 并且通过扩展高维几何对象细分为单纯形。 对于一个给定的点集， 有很多种三角剖分， 如： Delaunay 三角剖分定义在数学和计算几何中， 对于给定平面中的离散点集 $P$, 其 $Delaunay$ 三角剖分 $DT(P)$ 满足： 空圆性： $DT(P)$ 是 唯一 的（任意四点不共园）， 在 DT(P) 中, 任意三角形的外接圆范围内不会有其它点存在。 最大化最小角： 在点集 $P$ 可能形成的三角剖分中， $DT(P)$ 所形成的三角形的最小角最大。 从这个意义上来讲， $DT(P)$ 是最接近规则化的三角剖分。 具体说是在两个相邻的三角形构成的凸四边形的对角线， 在相互交换后， 两个内角的最小角不再增大。","categories":[{"name":"计算几何","slug":"计算几何","permalink":"https://cyx13935786602.github.io/categories/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://cyx13935786602.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}]},{"title":"Pick","slug":"Pick","date":"2020-01-17T06:45:29.000Z","updated":"2020-01-17T06:53:38.041Z","comments":true,"path":"2020/01/17/Pick/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/17/Pick/","excerpt":"","text":"定理描述Pick定理 : 给定整数坐标系， 在该系上的简单多边形， 其面积 $A$ 与内部格点数目 $i$, 边上格点数目 $b$ 有： $A = i + \\frac{b}{2} - 1$。 定理推广 取格点的组成图形面积为一单位。在平行四边形格点，Pick定理依然成立。 对于非简单的多边形 $P$ ， Pick定理 $A = i + \\frac{b}{2} - x(P)$, 其中 $x(P)$ 表示 $P$ 的 欧拉特征数。 Ehrhart多项式 Pick定理 和 欧拉公式 ($V - E + F = 2$) 等价。 例题 POJ1265","categories":[{"name":"计算几何","slug":"计算几何","permalink":"https://cyx13935786602.github.io/categories/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://cyx13935786602.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}]},{"title":"动态DP","slug":"动态DP","date":"2020-01-03T15:24:45.000Z","updated":"2020-01-03T15:45:09.645Z","comments":true,"path":"2020/01/03/动态DP/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/%E5%8A%A8%E6%80%81DP/","excerpt":"","text":"","categories":[{"name":"动态规划 - 优化","slug":"动态规划-优化","permalink":"https://cyx13935786602.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://cyx13935786602.github.io/tags/DP/"}]},{"title":"树形DP","slug":"树形DP","date":"2020-01-03T15:24:37.000Z","updated":"2020-01-03T15:37:29.608Z","comments":true,"path":"2020/01/03/树形DP/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/%E6%A0%91%E5%BD%A2DP/","excerpt":"","text":"","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://cyx13935786602.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://cyx13935786602.github.io/tags/DP/"}]},{"title":"区间DP","slug":"区间DP","date":"2020-01-03T15:24:28.000Z","updated":"2020-01-03T15:36:23.258Z","comments":true,"path":"2020/01/03/区间DP/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/%E5%8C%BA%E9%97%B4DP/","excerpt":"","text":"","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://cyx13935786602.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://cyx13935786602.github.io/tags/DP/"}]},{"title":"单调队列优化","slug":"单调队列优化","date":"2020-01-03T15:24:22.000Z","updated":"2020-01-03T15:48:47.792Z","comments":true,"path":"2020/01/03/单调队列优化/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/","excerpt":"","text":"","categories":[{"name":"动态规划 - 优化","slug":"动态规划-优化","permalink":"https://cyx13935786602.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://cyx13935786602.github.io/tags/DP/"}]},{"title":"斜率优化","slug":"斜率优化","date":"2020-01-03T15:24:10.000Z","updated":"2020-01-03T15:41:05.807Z","comments":true,"path":"2020/01/03/斜率优化/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/","excerpt":"","text":"","categories":[{"name":"动态规划 - 优化","slug":"动态规划-优化","permalink":"https://cyx13935786602.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://cyx13935786602.github.io/tags/DP/"}]},{"title":"四边形不等式优化","slug":"四边形不等式优化","date":"2020-01-03T15:24:01.000Z","updated":"2020-01-04T15:22:03.199Z","comments":true,"path":"2020/01/03/四边形不等式优化/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96/","excerpt":"","text":"","categories":[{"name":"动态规划 - 优化","slug":"动态规划-优化","permalink":"https://cyx13935786602.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://cyx13935786602.github.io/tags/DP/"}]},{"title":"WQS二分","slug":"WQS二分","date":"2020-01-03T15:23:50.000Z","updated":"2020-01-03T15:48:46.754Z","comments":true,"path":"2020/01/03/WQS二分/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/WQS%E4%BA%8C%E5%88%86/","excerpt":"","text":"","categories":[{"name":"动态规划 - 优化","slug":"动态规划-优化","permalink":"https://cyx13935786602.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://cyx13935786602.github.io/tags/DP/"}]},{"title":"后缀数组","slug":"后缀数组","date":"2020-01-03T15:23:24.000Z","updated":"2020-01-16T01:05:35.455Z","comments":true,"path":"2020/01/03/后缀数组/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/","excerpt":"","text":"算法相关后缀给出一个字符串S[1…n]，则后缀 $i$ 表示 S[i…n] 后缀数组将后缀 1 - n 按照字典序由小到大进行排序，得到SA数组为后缀数组。如：1234567S : helloSA : [2,1,4,3,5]1 : ello(后缀2)2 : hello(后缀1)3 : lo(后缀4)4 : llo(后缀3)5 : o(后缀5) 基数排序排序相关 求解方法这里介绍一种倍增求解的方法, 如图： 可以知道其时间复杂度为O($logn \\times T$), 其中 $T$ 为排序的时间复杂度。由此得到使用快速排序的时间复杂度为 O($nlog^2n$)。但我们通常改用基数排序的方法使得其时间复杂度降为 O($nlogn$)， 以达到更高的效率。 因此我们可以得到如下算法步骤： 得到当前字符串长度 $k$（由 $1$ 开始倍增） 获取 $n$ 个字符串 , 第 $i$ 个字符串(后缀 $i$ )组成为 [$x$, $y$] : [$rank_i$, $rank_{i+k}$]) 对 $n$ 个字符串进行排序并维护新的rank数组 当rank数组中所有值均不相同时停止倍增(由于已经两两互异，继续倍增已不会对rank数组产生影响) 维护SA数组(基数排序过程中可以顺带维护)代码实现","categories":[{"name":"字符串","slug":"字符串","permalink":"https://cyx13935786602.github.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://cyx13935786602.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"KMP","slug":"KMP","date":"2020-01-03T15:23:15.000Z","updated":"2020-01-03T15:28:00.017Z","comments":true,"path":"2020/01/03/KMP/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/KMP/","excerpt":"","text":"","categories":[{"name":"字符串","slug":"字符串","permalink":"https://cyx13935786602.github.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://cyx13935786602.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"AC自动机","slug":"AC自动机","date":"2020-01-03T15:22:55.000Z","updated":"2020-01-03T15:27:21.837Z","comments":true,"path":"2020/01/03/AC自动机/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/","excerpt":"","text":"","categories":[{"name":"字符串","slug":"字符串","permalink":"https://cyx13935786602.github.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://cyx13935786602.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Manachar","slug":"Manachar","date":"2020-01-03T15:22:35.000Z","updated":"2020-01-04T03:52:44.440Z","comments":true,"path":"2020/01/03/Manachar/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/Manachar/","excerpt":"","text":"算法简述给定一个长度为 $n$ 的字符串 $s$, 找到所有的数对 (i, j), 使得字串s[i…j]是回文串。 当且仅当 $t = t_{rec}$ 时， 字符串 $t$ 为一个回文子串。 朴素算法用 O($n^2$) 时间预处理出所有回文串， 而Manachar算法可以在 O(n) 线性时间内预处理出所需答案。 算法内容我们设数组 P[ ] 为以 $i$ 为中心的向右扩展回文串长度。 我们假设我们已经维护前 $i - 1$ 的 P[ ]。设 $maxlen$ 为前 $i - 1$ 个 字串(l, r)中的最大右边界 $r_{max}$, $cet$ 为该字串中心, 在我们维护 P[ i ] 时有以下情况： 当 $i + P[2 cet - i] &lt;= maxlen$ 时 : P[i] = P[2 cet - i]; 相关证明：我们已知道 (l = cet - P[cet], r = cet + P[cet]) 是以 $cet$ 为中心的回文串， 算法实际情况如图： \\ldots\\ \\overbrace{s_{l + 1}\\ \\ldots\\ \\underbrace{s_{j - P[j] + 1}\\ \\ldots\\ s_{j}\\ \\ldots\\ s_{j + P[j] - 1}}_\\text{回文串}\\ \\ldots\\ \\underbrace{s_{i - P[j] + 1}\\ \\ldots\\ s_{i}\\ \\ldots\\ s_{i + P[j] - 1}}_\\text{回文串}\\ \\ldots\\ s_{r - 1}\\ }^\\text{回文串} \\ldots 当 $i + P[2 * cet - i] &gt; maxlen$ 时 ： P[i] = maxlen - i; 相关证明：如图： \\ldots\\ \\overbrace{\\underbrace{s_{l + 1}\\ \\ldots\\ s_{j}\\ \\ldots\\ s_{j + (r - i) - 1}}_\\text{字符串}\\ \\ldots\\ \\underbrace{s_{i - (r - i) + 1}\\ \\ldots\\ s_{i}\\ \\ \\ldots\\ s_{r - 1}}_\\text{字符串}\\ }^\\text{回文串} \\ldots 因此 P[ i ] = min { P[2 * cet - i] , maxlen - i } 但此时的 P[ i ] 还并不是正确的值，我们接下来可以用朴素算法维护出正确的 P[ i ];1while(s[i + P[i]] == s[i - P[i]]) P[i]++; 代码实现123#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;","categories":[{"name":"字符串","slug":"字符串","permalink":"https://cyx13935786602.github.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://cyx13935786602.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Kruskal重构树","slug":"Kruskal重构树","date":"2020-01-03T15:22:01.000Z","updated":"2020-01-03T15:28:46.547Z","comments":true,"path":"2020/01/03/Kruskal重构树/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"0-1树","slug":"0-1树","date":"2020-01-03T15:20:20.000Z","updated":"2020-01-03T15:26:32.041Z","comments":true,"path":"2020/01/03/0-1树/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/0-1%E6%A0%91/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"可持续化数据结构","slug":"可持续化数据结构","permalink":"https://cyx13935786602.github.io/tags/%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"主席树","slug":"主席树","date":"2020-01-03T15:20:12.000Z","updated":"2020-01-03T15:42:25.715Z","comments":true,"path":"2020/01/03/主席树/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/","excerpt":"","text":"","categories":[{"name":"数据结构 - 可持续化","slug":"数据结构-可持续化","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%8C%96/"}],"tags":[{"name":"可持续化数据结构","slug":"可持续化数据结构","permalink":"https://cyx13935786602.github.io/tags/%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数据结构","slug":"数据结构","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"LCT","slug":"LCT","date":"2020-01-03T15:19:47.000Z","updated":"2020-01-03T15:29:10.501Z","comments":true,"path":"2020/01/03/LCT/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/LCT/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"树套树","slug":"树套树","date":"2020-01-03T15:19:39.000Z","updated":"2020-01-03T15:38:42.116Z","comments":true,"path":"2020/01/03/树套树/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/%E6%A0%91%E5%A5%97%E6%A0%91/","excerpt":"","text":"","categories":[{"name":"数据结构 - 嵌套","slug":"数据结构-嵌套","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B5%8C%E5%A5%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"嵌套","slug":"嵌套","permalink":"https://cyx13935786602.github.io/tags/%E5%B5%8C%E5%A5%97/"}]},{"title":"Treap","slug":"Treap","date":"2020-01-03T15:18:59.000Z","updated":"2020-01-04T15:35:40.926Z","comments":true,"path":"2020/01/03/Treap/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/Treap/","excerpt":"","text":"","categories":[{"name":"数据结构 - 平衡树","slug":"数据结构-平衡树","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B3%E8%A1%A1%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"平衡树","slug":"平衡树","permalink":"https://cyx13935786602.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"}]},{"title":"Splay","slug":"Splay","date":"2020-01-03T15:18:53.000Z","updated":"2020-01-04T15:36:05.947Z","comments":true,"path":"2020/01/03/Splay/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/Splay/","excerpt":"","text":"","categories":[{"name":"数据结构 - 平衡树","slug":"数据结构-平衡树","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B3%E8%A1%A1%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"平衡树","slug":"平衡树","permalink":"https://cyx13935786602.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"}]},{"title":"左偏树","slug":"左偏树","date":"2020-01-03T15:18:41.000Z","updated":"2020-01-04T03:15:16.468Z","comments":true,"path":"2020/01/03/左偏树/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/%E5%B7%A6%E5%81%8F%E6%A0%91/","excerpt":"","text":"","categories":[{"name":"数据结构 - 堆","slug":"数据结构-堆","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"堆","slug":"堆","permalink":"https://cyx13935786602.github.io/tags/%E5%A0%86/"}]},{"title":"数值积分","slug":"数值积分","date":"2020-01-03T15:17:38.000Z","updated":"2020-01-03T15:38:31.471Z","comments":true,"path":"2020/01/03/数值积分/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86/","excerpt":"","text":"","categories":[{"name":"数学","slug":"数学","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"微积分","slug":"微积分","permalink":"https://cyx13935786602.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"}]},{"title":"分段打表","slug":"分段打表","date":"2020-01-03T15:17:16.000Z","updated":"2020-01-03T15:34:18.959Z","comments":true,"path":"2020/01/03/分段打表/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/%E5%88%86%E6%AE%B5%E6%89%93%E8%A1%A8/","excerpt":"","text":"","categories":[{"name":"数学 - 暴力","slug":"数学-暴力","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E5%AD%A6-%E6%9A%B4%E5%8A%9B/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"暴力","slug":"暴力","permalink":"https://cyx13935786602.github.io/tags/%E6%9A%B4%E5%8A%9B/"}]},{"title":"牛顿迭代法","slug":"牛顿迭代法","date":"2020-01-03T15:17:03.000Z","updated":"2020-01-03T15:35:43.603Z","comments":true,"path":"2020/01/03/牛顿迭代法/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/","excerpt":"","text":"","categories":[{"name":"数学","slug":"数学","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"迭代法","slug":"迭代法","permalink":"https://cyx13935786602.github.io/tags/%E8%BF%AD%E4%BB%A3%E6%B3%95/"}]},{"title":"线性代数","slug":"线性代数","date":"2020-01-03T15:16:38.000Z","updated":"2020-01-03T15:39:55.083Z","comments":true,"path":"2020/01/03/线性代数/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/","excerpt":"","text":"","categories":[{"name":"数学","slug":"数学","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"线性规划","slug":"线性规划","date":"2020-01-03T15:16:28.000Z","updated":"2020-01-03T15:40:32.274Z","comments":true,"path":"2020/01/03/线性规划/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/","excerpt":"","text":"","categories":[{"name":"数学","slug":"数学","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"博弈论学习","slug":"博弈论学习","date":"2020-01-03T15:16:13.000Z","updated":"2020-01-03T15:32:57.951Z","comments":true,"path":"2020/01/03/博弈论学习/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"","categories":[{"name":"数学 - 博弈论","slug":"数学-博弈论","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E5%AD%A6-%E5%8D%9A%E5%BC%88%E8%AE%BA/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"斐波那契数列","slug":"斐波那契数列","date":"2020-01-03T15:15:48.000Z","updated":"2020-01-29T09:51:01.864Z","comments":true,"path":"2020/01/03/斐波那契数列/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/","excerpt":"","text":"简介斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：$1、1、2、3、5、8、13、21、34、\\ldots$在数学上，斐波那契数列以如下被以递推的方法定义：$F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)(n \\ge 3，n \\in N^*)$ 在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从1963年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。 ——摘自百度百科 通项公式由特征方程求解， 由于在OI中通项公式不常用到（但是仍然有用）， 这里只给出解析解， 不给出证明， 证明可参考特征方程。 F_n = \\frac{\\left(\\frac{1 + \\sqrt{5}}{2}\\right)^n - \\left(\\frac{1 - \\sqrt{5}}{2}\\right)^n}{\\sqrt{5}}进一步的， 由于第二项指数级的减小， 所以可以写成： F_n = \\left[\\frac{\\left(\\frac{1+\\sqrt5}{2}\\right)^n}{\\sqrt5}\\right]中括号表示取离它最近的整数。 注意! 这两个式子在计算时需要极高的精确度 性质 这里列出相关性质与其简易证明： Cassini’s identity : $F_{n-1}F_{n+1}-F_{n}^2 = (-1)^n$ 附加性质 : $F_{n + k} = F_kF_{n + 1} + F_{k-1}F_n$ 取 (2) 中 $k = n$, 得到 $F_{2n} = F_{n}(F_{n + 1} + F_{n - 1})$ 对 (3) 进行数学归纳得, $\\forall k \\in \\mathbb{N}, F_{n} | F_{nk}$ 由于 (4) 可逆， 得到 $\\forall F_a | F_b, a | b$ GCD性质: $\\gcd(F_n, F_m) = F_{\\gcd(n, m)}$ 前缀和性质： $\\Sigma_{i = 1}^{n}F_i = F_{n+2} - 1$ $\\Sigma_{i=1}^{n}{i \\times F_i} = nF_{n+2} - F_{n+3} + 2$ 证明性质(1)待施工 模意义下的周期性考虑模 $p$ 意义下的斐波那契数列， 由抽屉原理易证，该数列有周期性。考虑模 $p$ 意义下的斐波那契数列的前 $p^{2} + 1$个相邻数对: (F_1,F_2),(F_2,F_3),\\ldots,(F_{p^2+1}, F_{p^2+2})由于 $p$ 的剩余系大小为 $p$, 则这 $p^2 + 1$ 个数对中必有二项完全相同，则由此两项推出的数完全相同，原命题得证。 求解方法递推法由递推公式 $F_{i+2} = F_{i+1} + F_{i}$ 在O(n)内得到。 矩阵快速幂斐波那契矩阵表达式： \\begin{bmatrix} F_{i+2}\\\\ F_{i+1}\\\\ \\end{bmatrix} = \\begin{bmatrix} 1&1\\\\ 1&0\\\\ \\end{bmatrix} \\cdot \\begin{bmatrix} F_{i+1}\\\\ F_{i}\\\\ \\end{bmatrix}令$P = \\begin{bmatrix}1&amp;1\\\\1&amp;0\\end{bmatrix}$, 得到 $\\begin{bmatrix}F_{n+2}\\\\F_{n+1}\\end{bmatrix}=P^n \\cdot \\begin{bmatrix}F_2\\\\F_1\\end{bmatrix}$ 快速倍增法由其性质(2)得到： F_{2n} = F_{n}(2F_{n+1} - F_{n})\\\\ F_{2n+1} = F_{n+1}^2 + F_{n}^2\\\\可以通过二元组($F_{i+1}$, $F_i$), 进行倍增运算代码如下：12345678910pair&lt;int, int&gt; fib(int n) &#123; if (n == 0) return &#123;0, 1&#125;; auto p = fib(n &gt;&gt; 1); int c = p.first * (2 * p.second - p.first); int d = p.first * p.first + p.second * p.second; if (n &amp; 1) return &#123;d, c + d&#125;; else return &#123;c, d&#125;;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Min_25筛","slug":"Min-25筛","date":"2020-01-03T15:14:55.000Z","updated":"2020-01-03T15:47:58.362Z","comments":true,"path":"2020/01/03/Min-25筛/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/Min-25%E7%AD%9B/","excerpt":"","text":"","categories":[{"name":"数学 - 数论","slug":"数学-数论","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"杜教筛","slug":"杜教筛","date":"2020-01-03T15:14:38.000Z","updated":"2020-01-03T15:33:40.530Z","comments":true,"path":"2020/01/03/杜教筛/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/%E6%9D%9C%E6%95%99%E7%AD%9B/","excerpt":"","text":"","categories":[{"name":"数学 - 数论","slug":"数学-数论","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"莫比乌斯反演","slug":"莫比乌斯反演","date":"2020-01-03T15:14:25.000Z","updated":"2020-01-03T15:35:09.139Z","comments":true,"path":"2020/01/03/莫比乌斯反演/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/","excerpt":"","text":"","categories":[{"name":"数学 - 数论","slug":"数学-数论","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Lucas定理","slug":"Lucas定理","date":"2020-01-03T15:14:05.000Z","updated":"2020-01-16T01:06:13.459Z","comments":true,"path":"2020/01/03/Lucas定理/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/Lucas%E5%AE%9A%E7%90%86/","excerpt":"","text":"定理描述Lucas 定理用于求解组合数取模问题，其中模数 $p$ 为质数。 Lucas 定理 : $C_{n}^{m} \\equiv \\prod_{i = 1}^{k} C_{n_i}^{m_i} \\pmod p$, 其中 $n_i, m_i$ 为 $n, m$ 在 $p$ 进制下第 $i$ 位的数字 定理证明考虑 $C_{p}^{n} \\bmod p$ 的取值， 因为 $\\displaystyle C_{p}^{n} = \\frac{p!}{n!(p-n)!}$ ，分子的质因数分解中 $p$ 次项恰好为 $1$, 因此只有当 $n = 0$ 或 $n = p$ 时, 分子 $n!(p - n)!$ 的质因数分解中含有 $p$ , 因此 $C_{p}^{n} \\bmod p = [n = 0 \\vee n = p]$ 。 由此, 我们可以得到更强的结论： \\begin{align} (a + b) ^ {p} &= \\Sigma_{n = 0}^{p} C_{p}^{n}a^{n}b^{p-n} \\\\ &\\equiv \\Sigma_{n = 0}^{p}[n = 0 \\vee n = p]a^{n}b^{p-n} \\pmod p\\\\ &\\equiv a^{p} + b^{p} \\pmod p\\\\ \\end{align} Tips:此结论不仅适用于整数域， 同样适用于多项式。 由此可推导出二项式 $f(x) = (ax^{n} + bx^m)^p \\bmod p$ 的结果为： \\begin{align} (ax^n + bx^m) ^ p &\\equiv a^px^{pn} + b^{p}x^{pm} \\\\ &\\equiv ax^{pn} + bx^{pm} \\\\ &\\equiv f(x^p) \\pmod p \\\\ \\end{align} 考虑二项式 $(1 + x)^n \\bmod p$, 那么 $C_{n}^{m}$ 就是求二项式在 $x_{m}$ 次项的值。使用上述引理， 可以知道： \\begin{align} (1 + x) ^ {n} &\\equiv (1 + x) ^ {p\\lfloor n/p \\rfloor}(1 + x)^{n \\bmod p}\\\\ &\\equiv (1 + x^{p})^{\\lfloor n/p \\rfloor}(1 + x)^{n \\bmod p}\\\\ \\end{align}注意到前者只有在 $p$ 的倍数处才能产生贡献，而对于后者有 $n \\bmod p \\le p - 1$, 因此其卷积在任何位置只有最多一种方式产生贡献，得到： \\binom{m}{n} \\equiv \\binom{\\lfloor m/q \\rfloor}{\\lfloor n/q \\rfloor} \\times \\binom{m \\bmod p}{n \\bmod p} \\pmod p代码实现(c++)1#include&lt;iostream&gt;","categories":[{"name":"数学","slug":"数学","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"BGSG","slug":"BGSG","date":"2020-01-03T13:44:28.000Z","updated":"2020-03-04T01:31:59.192Z","comments":true,"path":"2020/01/03/BGSG/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/BGSG/","excerpt":"","text":"算法简介BSGS（baby-step gaint-step），即大步小步算法。常用于求解离散对数问题。 a^x \\equiv b \\pmod p其中$a \\perp p$。 方程的解 $x$ 满足 $0 \\le x &lt; p$。 算法过程 设集合S = {$k | k = a^i \\bmod p$} 计算$a^i \\bmod p , i \\in [1, \\sqrt p]$, 加入集合S 在集合S中查找b，若不存在所需元素，则$b = b \\times a^{\\sqrt p} \\bmod p$；若存在该元素，则得到一个可行解。 算法证明因为$a \\perp b$， 所以由费马小定理得到$a^{p - 1} = 1 \\pmod p$； 因此只需要求解$x \\in [1, p - 1]$ 中的解$x$即可（ $x &gt; p$ 后所得值重复）。由此得到朴素O（p）算法：枚举x的值。 对该算法进行优化，运用分块思想， 将总序列分为 T 块，则每块元素个数为 $\\left( \\frac{p}{T} \\right)$, 得到总时间复杂度为O($\\frac{p}{T} + T$), 易证当 $T = \\sqrt p$ 时时间复杂度最低。 时间复杂度计算 [1, $\\sqrt p$] 为 O($\\sqrt p$), 之后最多 $\\sqrt p$ 次查询。 总时间复杂度为$O(\\sqrt p)$ Code12#include&lt;iostream&gt;#include&lt;cstdio&gt;","categories":[{"name":"数学 - 数论","slug":"数学-数论","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"中国剩余定理-CRT","slug":"中国剩余定理-CRT","date":"2020-01-03T13:38:12.000Z","updated":"2020-01-03T16:23:38.630Z","comments":true,"path":"2020/01/03/中国剩余定理-CRT/","link":"","permalink":"https://cyx13935786602.github.io/2020/01/03/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86-CRT/","excerpt":"","text":"算法简介中国剩余定理（Chinese Remainder Theorem, CRT）是用来求解如下形式的一元线性同余方程组($\\forall b_{k} \\in N$) ： \\begin{cases} x &\\equiv& a_1 \\pmod {b_{1}}\\\\ x &\\equiv& a_2 \\pmod {b_{2}}\\\\ &\\vdots&\\\\ x &\\equiv& a_n \\pmod {b_{n}}\\\\ \\end{cases}前置知识两个方程合并 设两个方程分别为 ：$x \\equiv a_1 \\pmod {m_1}$,$x \\equiv a_2 \\pmod {m_2}$. 转化为不定方程：$x = m_1p + a_1, x = m_2q + a_2$ , $p, q \\in N^*$,则有$m_1p - m_2q = a_2 - a_1$. 由裴蜀定理， 当 $a_2 - a_1$ 不能被 $\\gcd(m_1, m_2)$ 整除时， 无解； 其他情况下， 可通过EXGCD解出来一组可行解 $(p, q)$ ； 则原来的两个方程组成的模方程组的解为$x \\equiv b \\pmod M$, 其中 $b = m_1p + a_1, M = \\text{lcm}(m_1, m_2)$ 算法流程 获取两个模方程 合并两个模方程 重复上述操作， 得到所有模方程的合并方程代码实现123#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;","categories":[{"name":"数学 - 数论","slug":"数学-数论","permalink":"https://cyx13935786602.github.io/categories/%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数论","slug":"数论","permalink":"https://cyx13935786602.github.io/tags/%E6%95%B0%E8%AE%BA/"}]}]}